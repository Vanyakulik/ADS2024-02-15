package by.it.group310901.eremeiko.lesson14;

import java.util.Arrays;
import java.util.Scanner;

public class StatesHanoiTowerC {

    // Рекурсивная функция для решения задачи Ханойских башен
    static void rekr(Integer[] s, Integer h, Integer[] ans, Integer fr, Integer to){
        // Если нужно переместить только одно кольцо
        if(h == 1){
            s[to]++;  // Перемещаем кольцо на стержень "to"
            s[fr]--;  // Убираем кольцо с исходного стержня "fr"
            // Находим наибольшую высоту на стержнях A, B и C и увеличиваем соответствующий счетчик
            ans[s[0] > s[1] ? (s[0] > s[2] ? s[0] : s[2]) : (s[2] > s[1] ? s[2] : s[1])]++;
        } else {
            // Находим промежуточный стержень (тот, который не является ни "fr", ни "to")
            int temp = (fr == 0 ? to == 1 ? 2 : 1 : fr == 1 ? to == 0 ? 2 : 0 : to == 1 ? 0 : 1);
            // Рекурсивно решаем задачу для меньшего количества колец (h - 1)
            rekr(s, h - 1, ans, fr, temp);
            s[to]++;
            s[fr]--;
            // Снова находим наибольшую высоту на стержнях A, B и C и увеличиваем соответствующий счетчик
            ans[s[0] > s[1] ? (s[0] > s[2] ? s[0] : s[2]) : (s[2] > s[1] ? s[2] : s[1])]++;
            // Рекурсивно решаем задачу для оставшихся колец
            rekr(s, h - 1, ans, temp, to);
        }
    }

    public static void main(String[] args){
        // Создаем сканер для считывания входных данных
        Scanner in = new Scanner(System.in);
        // Читаем количество колец
        Integer n;
        n = in.nextInt();
        // Массив для хранения информации о количестве колец на каждом из стержней A, B и C
        Integer[] ans = new Integer[n + 1], s = new Integer[3];
        // Изначально все кольца находятся на стержне A (s[0] = n), остальные стержни пустые (s[1] = s[2] = 0)
        s[0] = n; s[1] = 0; s[2] = 0;
        // Инициализация массива ans, который будет хранить количество шагов для каждого возможного числа колец на стержне
        for(int i = 0; i <= n; ++i)
            ans[i] = 0;
        // Рекурсивный вызов для переноса колец с A на B с использованием C как промежуточного стержня
        rekr(s, n, ans, 0, 2);
        // Сортируем массив ans для получения ответа
        Arrays.sort(ans);
        // Выводим все элементы массива ans, которые больше нуля (то есть количество шагов для каждого размера поддерева)
        for(int i = 0; i < ans.length; ++i)
            if(ans[i] > 0) {
                System.out.print(ans[i]);
                System.out.print(' ');
            }
    }
}
